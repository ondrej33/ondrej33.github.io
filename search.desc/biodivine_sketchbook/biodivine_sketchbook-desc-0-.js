searchState.loadedDescShard("biodivine_sketchbook", 0, "All the internal algorithms for the inference process and …\nGeneral functionality for session management, windows, …\nVersion of <code>log</code> with <code>DEBUG</code> severity.\nVersion of <code>log</code> with <code>ERROR</code> severity.\nGenerate two enums for property variants - one where each …\nState of the inference analysis and computation solvers.\nVersion of <code>log</code> with <code>VERBOSE</code> severity.\nThis is an initial attempt at a useful internal <code>log</code> macro. …\nCustom logging utilities.\nState of the BN sketch, and management for most of the …\nVersion of <code>log</code> with <code>WARNING</code> severity.\nEvaluation of dynamic properties (by either HCTL model …\nEvaluation of static properties (by either FO logic …\nParsing and evaluation of first-order formulas. …\nUseful utilities for manipulating symbolic contexts and …\nInternal algorithms for attractor computation (adapted …\nInternal algorithms for trap space computation (adapted …\nEncode data and template properties into HCTL.\nEvaluate all kinds of dynamic properties.\nPrepare graph and symbolic context to handle all dynamic …\nProcessed variants of dynamic properties for evaluation.\nInterleaved transition guided reduction quickly eliminates …\nProcess a component found by Xie-Beerel (attractor …\nReachability algorithms that use saturation for improved …\nCompute terminal SCCs, and sort all the colors according …\nXie-Beerel TSCC algorithm\n<strong>(internal)</strong> Basic backward reachability process.\n<strong>(internal)</strong> Computes the extended component of a …\n<strong>(internal)</strong> Basic forward reachability process.\n<strong>(internal)</strong> A process trait is a unit of work that is …\n<strong>(internal)</strong> Computes the set of vertices reachable from …\n<strong>(internal)</strong> Scheduler manages work divided into <code>Processes</code>. …\nMark the given set of states as eliminated - i.e. they can …\nRemove given <code>var</code> from the list of active variables.\nRemove given <code>set</code> from the universe of this scheduler.\nFinalize this scheduler, returning the current universe …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the list of currently active variables.\nGet the current universe set of the scheduler.\nRemoves from <code>initial</code> as many non-attractor states as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if all processes are finished.\nCreate a new <code>Scheduler</code> with initial universe and active …\nAdd a new process into this scheduler.\nPerform one step in the process. This can perform multiple …\nIf possible, perform one computational step for one of the …\nApproximate symbolic complexity of the process.\nFully compute back-reachable states from <code>initial</code> inside …\nPerforms one reachability step using the saturation scheme.\nUses a simplified Xie-Beerel algorithm adapted to coloured …\nCompute colors where each given observation corresponds to …\nCompute colors where each given observation corresponds to …\nWrapper to compute all essential colored trap spaces …\nWrapper to compute all minimal colored trap spaces (under …\nUtility to encode observation as a singleton “…\nEncode a dataset of observations as a single HCTL formula. …\nEncode several observation vectors with conjunction …\nEncode binarized observation with a formula depicting the …\nCreate HCTL formula describing that given sub-space …\nCreate HCTL formula describing that each sub-space …\nCreate HCTL formula describing that given specific state …\nCreate HCTL formula describing that 1) each sub-space …\nCreate HCTL formula describing that 1) each sub-space …\nCreate HCTL formula describing that given sub-space …\nCreate HCTL formula describing that each sub-space …\nCreate HCTL formula describing that given state is a …\nCreate HCTL formula that prohibits existence of any …\nCreate HCTL formula that prohibits existence of any steady …\nCreate a formula describing the existence of path between …\nCreate HCTL formula describing that there is (not) a path …\nCreate a formula describing that a sub-space (observation) …\nCreate a formula describing that each sub-space …\nEncode each of the several observations, one by one. For …\nEncode an observation by a (propositional) formula …\nEvaluate given dynamic property given the symbolic …\nModel check a property and get colors for which the …\nPrepare the symbolic context and generate the symbolic …\nPrepare the symbolic context and generate the symbolic …\nPrepare the symbolic context and generate the symbolic …\nEnum of possible variants of data encodings via HCTL.\nProperty requiring that the number of attractors falls …\nEnum for processed variants of dynamic properties.\nProperty requiring that a particular HCTL formula is …\nProperty requiring that observations in a particular …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet ID of the underlying processed property.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate attractor-count <code>ProcessedDynProp</code> instance.\nCreate HCTL <code>ProcessedDynProp</code> instance.\nCreate trap-space <code>ProcessedDynProp</code> instance. To encode …\nProcess dynamic properties in a sketch, converting them …\nEncode regulations and template properties into FOL.\nEvaluate all kinds static properties.\nPrepare graph and symbolic context to handle all static …\nProcessed variants of static properties for evaluation.\nCreate a FOL formula encoding that uninterpreted function…\nCreate a FOL formula encoding that uninterpreted function…\nCreate a FOL formula encoding that particular formula must …\nCreate a FOL formula encoding that a regulation has given …\nCreate a FOL formula encoding that a regulation has given …\nEvaluate given static property.\nPrepare the symbolic context and generate the symbolic …\nPrepare the symbolic context and generate the symbolic …\nProcessed static property encoded in FOL.\nReturns the argument unchanged.\nGet ID of the processed property.\nCalls <code>U::from(self)</code>.\nCreate FOL <code>ProcessedStatProp</code> instance.\nProcess static properties from a sketch, converting them …\nEvaluate uninterpreted function applied to given arguments.\nEvaluate update function symbol applied to given arguments.\nEvaluate the equivalence operation.\nEvaluate existential quantifier.\nEvaluate universal quantifier.\nEvaluate the implication operation.\nEvaluate negation respecting the allowed universe.\nRecursively evaluate the sub-formula represented by a <code>node</code> …\nEvaluate a variable term.\nEvaluate the non-equivalence operation (xor).\nEvaluate given formula a given transition <code>graph</code>. The <code>graph</code> …\nEvaluate given formula, but do not sanitize the result. …\nEvaluate each of a list of FOL formulas on a given …\nEvaluate each of a list of FOL formulas, but do not …\nEvaluate each of a list of FOL formulas given by their …\nEvaluate each of a list of FOL formulas given by their …\nEvaluate formula given by its syntactic tree. The <code>graph</code> …\nEvaluate formula given by its syntactic tree, but do not …\nParse given FOL formulas list into syntactic trees and …\nA single node in a syntax tree of a FOL formula.\nEnum of possible node data types in a FOL formula syntax …\nReturns the argument unchanged.\nReturns the argument unchanged.\nRecursively obtain the <code>FolTreeNode</code> from a similar <code>FnUpdate</code> …\n“Parse” a new FolTreeNode from a list of FolToken …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA helper function which creates a new FolTreeNode for the …\nCreate a “binary” FolTreeNode from the given arguments.\nCreate a FolTreeNode representing a Boolean constant.\nCreate a FolTreeNode representing a function symbol …\nCreate a “quantifier” FolTreeNode from the given …\nCreate a “unary” FolTreeNode from the given arguments.\nCreate a FolTreeNode representing a variable.\nCreate a copy of this FolTreeNode with every occurrence of …\nEnum for atomic terms: variables and constants.\nA named function symbol with a boolean flag whether the …\nEnum for quantifiers in a FOL formula string.\nEnum for all possible Boolean unary operators occurring in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUtility method to find the first occurrence of a specific …\nUtility method to find the first occurrence of a …\nUtility method to find the first occurrence of an unary …\nPredicate for whether given token represents a quantifier.\nPredicate for whether given token represents unary …\nRecursive parsing step 1: extract quantifier operators.\nRecursive parsing step 2: extract <code>&lt;=&gt;</code> operators.\nRecursive parsing step 3: extract <code>=&gt;</code> operators.\nRecursive parsing step 4: extract <code>|</code> operators.\nRecursive parsing step 5: extract <code>^</code> operators.\nRecursive parsing step 6: extract <code>&amp;</code> operators.\nRecursive parsing step 7: extract unary operators (just a …\nRecursive parsing step 8: extract terms and recursively …\nParse an FOL formula string representation into an actual …\nParse an FOL formula string representation into an actual …\nParse <code>tokens</code> of FOL formula into an abstract syntax tree …\nEnum of all possible tokens occurring in a FOL formula …\nRetrieve the arguments of a function, process everything …\nRetrieve the name (of a proposition or variable) from the …\nDisplay tokens for debug purposes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPredicate to decide if a given “name” represents <code>false</code> …\nPredicate to decide if a given “name” represents <code>true</code> …\nCheck if given char can appear in a name.\nCheck if given char can appear in a name.\nPrint the vector of tokens (for debug purposes).\nRecursively display tokens.\nDecide whether the name corresponds to a constant or a …\nCheck all whitespaces at the front of the iterator.\nTry to tokenize given FOL formula string, turning it into …\nProcess a peekable iterator of characters into a vector of …\nCheck that symbolic context supports given function symbol …\nCheck that extended symbolic graph’s BDD supports given …\nCheck that BN has given variable, and that it has given …\nCompute the set of all unique function symbols (with …\nCompute the set of all uniquely named FOL variables in the …\nCompute a valid name for an “anonymous update function”…\nFor a given FOL variable name, get a base variable of the …\nIf the provided function symbol corresponds to (implicit) …\nCheck if a given function symbol name corresponds to an …\nChecks that all FOL variables in the formula’s syntactic …\nChecks that all FOL variables in the formula’s syntactic …\nLabel for frontend events that are changing the app state.\nLabel for backend-only events for simple “request-answer…\nLabel for frontend events that are requesting a value …\nLabel for backend events that are notifying about a state …\nServes as a global “application context” through which …\nAeonError is an implementation of Error which is intended …\nID of the default initial editor session.\nID of the initial window of the default editor session.\nA DynError is a “generic” heap-allocated trait object …\nServes as a global “application context” through which …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAeonError is an implementation of Error which is intended …\nThe same as Self::new, but returns DynError instead.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new instance of AeonError with the provided …\nCreate a new instance of AeonError, convert it to DynError …\nThe same as AeonError::throw, but also includes a generic …\nAn Event object holds information about one particular …\nA SessionMessage represents a single event “message” …\nA StateChange is internally the same as UserAction, but it …\nA UserAction is a collection of events that originate in …\nAn estimated amount of bytes consumed by the data stored …\nAn estimated size of this UserAction in bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStruct to wrap “user action” (…\nStruct to wrap “backend message” (…\nStruct to wrap “refresh” requests sent from front-end …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAppState implements mapping between session IDs and …\nAtomic state is a SessionState which holds exactly one …\nA Consumed object describes possible outcomes of trying to …\nThe action was consumed, but the provided user input is …\nAction was successfully consumed, resulting in the given …\nThe action was consumed, but the application state did not …\nAction cannot be consumed as is and should be instead …\nEvent was successfully consumed, resulting the provided …\nA Session with a UndoStack with events.\nA utility function to assert that path has a given length, …\nA utility function to assert that payload is empty - …\nA utility function to get and clone a payload of an event. …\nDeclares top-level state objects that are unique to the …\nReturns the string identifier of this particular session. …\nDeclares top-level state objects that are unique to the …\nA utility function which emits a generic “invalid path”…\nA utility function which emits a “invalid path” error …\nA utility function which checks if <code>at_path</code> is exactly\nPerform a user action on this session state object. This …\nPerform a user action on this session state object, with …\nModify the session state using the provided <code>event</code>. The …\nProcess a message sent to this session state object.\n“Read” session state into an event without modifying …\nA utility function which checks if <code>at_path</code> starts with a …\nReturns an immutable reference to session’s undo stack.\nReturns a mutable reference to session’s undo stack.\nA Consumed object describes possible outcomes of trying to …\nThe action was consumed, but the provided user input is …\nAction was successfully consumed, resulting in the given …\nThe action was consumed, but the application state did not …\nAction cannot be consumed as is and should be instead …\nEvent was successfully consumed, resulting the provided …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAppState implements mapping between session IDs and …\nEmit state change events to all front-end windows …\nReturns the argument unchanged.\nGet the ID of the session that owns given Window.\nGet IDs of all windows corresponding to a given session.\nCalls <code>U::from(self)</code>.\nRegister the newly created session to the AppState.\nRegister the newly created window to the corresponding …\nAtomic state is a SessionState which holds exactly one …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe stack that keeps track of all the events that can be …\nThe items on the undo/redo stack are pairs of events: one …\nRemove all elements from the UndoStack.\nThe approximate size of all payloads stored on the …\nNotify the undo stack that a new action has been …\nInternal function to drop an UndoStackEntry from the …\nThe number of events this <code>UndoStack</code> is allowed to track. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe number of bytes of payload that this <code>UndoStack</code> is …\nThe sum of payload sizes for the underlying UI actions.\nTry to redo the current top of the redo stack. This action …\nThe number of events that can be re-done.\nTry to undo the current top of the undo stack. This action …\nThe number of events that can be un-done.\nThe state of one editor session.\nDeclares EditorSession: the root state object of the …\nDeclares TabBarState: the state object of the main tab …\nThe state of one editor session.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe state of one editor session.\nDeclares InferenceSession: the root state object of the …\nThe state of one editor session.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUtilities to sample and download networks. Some …\nStructures and utilities to track final results of …\nStructures and methods to run the whole inference process. …\nStructures and utilities to track the whole state of …\nStructures and utilities to track progress status of …\nEnum with various supported inference types.\nUtilities to download results.\nStruct with details regarding candidate sampling.\nUtilities to explore canditate update functions.\nRandomly select a color from the given set of colors. This …\nObject encompassing inference results that are to be send …\nType of the conducted inference analysis.\nComputation time in miliseconds.\nAppend string to the end of current metadata.\nPrepare a formated summary of inference results, basically …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>InferenceResults</code> given all the details.\nNumber of satisfying networks.\nNumber of admissible update functions per each variable.\nAll status updates of the solver (from creation to finish).\nString message summarizing computation to be …\nObject encompassing a finished (successful) BN inference …\nObject encompassing the process of the BN inference …\nReference getter for a Boolean network.\nBoolean Network instance (once processed).\nSet the cancellation flag. The actual cancellation does …\nUtility to check whether the cancellation flag was set. If …\nUtility to check whether the sketch (during computation) …\nGet a current set of valid candidate colors. This can be …\nReference getter for a vector of formulas for dynamic …\nDynamic properties (once processed).\nPotential error message (if computation finishes with …\nEvaluate previously collected dynamic properties, and …\nEvaluate previously collected static properties, and …\nExtract and process BN component from the sketch.\nReference getter for a set of satisfying graph colors.\nFormat a computation status message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReference getter for a transition graph.\nSymbolic transition graph for the system. Its set of unit …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if computation finished (by success or error).\nPrepares new “empty” <code>InferenceSolver</code> instance that can …\nNumber of dynamic properties that were already …\nNumber of static properties that were already successfully …\nSet of final satisfying colors ((if computation finishes …\nCheck if InferenceStatus requires number of remaining …\nPotential processed results (if computation finishes …\nRun the prototype version of the inference using the given …\nA modular variant of the inference. You can choose which …\nChannel to send updates regarding the computation.\nFlag to signal cancellation.\nGet a start time of the actual computation.\nStart time of the computation (once started).\nReference getter for a vector of formulas for static …\nStatic properties (once processed).\nVector with all time-stamped status updates. The last is …\nIf computation successfully finished, transform into …\nGet a total duration of the actual inference computation.\nUpdate the status of the solver, and send a progress …\nInferenceState manages the main functionalities and …\nCheck if the results were already fetched from the solver.\nCopy of already finished inference solver instance, used …\nReturns the argument unchanged.\nGetter for pre-processed results from the internal solver. …\nGet reference to the sketch data of this <code>InferenceState</code>.\nIf a computation solver is running, send cancellation flag …\nCalls <code>U::from(self)</code>.\nCreate new <code>InferenceState</code> with a full sketch data.\nCreate new <code>InferenceState</code> with an empty placeholder sketch.\nPotential channel to receive (text) updates from the …\nPotential simplified processed results of the inference.\nUpdate the sketch data of this <code>InferenceState</code>.\nBoolean network sketch to run the inference on. Can be a …\nFlag signalling that the actual sketch data were received …\nPotential inference solver instance.\nStart the inference computation on a separate thread. If …\nCheck if the inference solver finished its computation. If …\nCheck if there are any new messages from the solver …\nInference solver instance is created.\nDetected that sketch is unsatisfiable (can happen at the …\nComputation is finished but unsuccessful (cancellation or …\nAll dynamic properties are evaluated.\nAll static properties are evaluated.\nStatic property is evaluated (can happen multiple times).\nStatic property is evaluated (can happen multiple times).\nComputation is successfully finished.\nSymbolic context and graph for dynamic props is created.\nSymbolic context and graph for static props is created.\nStatus of the inference computation.\nReport on status of the computation, together with few …\nSketch input is processed (BN object created, …).\nThe inference computation is started.\nComputation time (from the start) as a number of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMessage to be shown at the frontend.\nCreate new <code>InferenceStatusReport</code> given all the details.\nOptional number of remaining candidates (not needed for …\nNew status of the inference computation.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExport archive with complete results to the given path. …\nFor a given variable, get all valid interpretations of its …\nHelper function to write string into a zip archive file.\nStructure for receiving data about network sampling …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>SamplingData</code> object given all its fields.\nFor a given variable, get all valid interpretations of its …\nFor each variable, compute number of valid interpretations …\nDisable logging.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if logging is enabled.\nTrait that implements <code>to_json_str</code> and <code>from_json_str</code> …\nTrait implementing functionality relevant for all manager …\nObject encompassing all of the individual modules of the …\nThe main <code>Sketch</code> manager object and its utilities.\nCheck that the list of (typesafe or string) IDs contains …\nCheck that the list of (typesafe or string) IDs contains …\nUtilities regarding conversion of BN components and …\nStructs and utility methods that can be used for …\n<strong>(internal)</strong> Utility functions specifically related to …\nWrapper for json de-serialization.\nGenerate an ID of type <code>T</code> for a certain component of a …\nDefinitions and utilities for type-safe identifiers of …\nStructs and utility methods regarding the layout of the …\nStructs and utility methods regarding the model of the …\nStructs and utility methods regarding observations and …\nClasses and utility methods regarding properties.\nWrapper for json serialization.\nWrapper for <em>pretty</em> json serialization with indentation.\n<strong>(internal)</strong> General utilities used throughout the module …\nObject encompassing all of the individual modules of the …\n<strong>(internal)</strong> Utilities to check consistency of <code>Sketch</code> …\n<strong>(internal)</strong> Exporting sketch in various formats.\n<strong>(internal)</strong> Importing sketch in various formats.\n<strong>(internal)</strong> Implementation of event-based API for the …\n<strong>(internal)</strong> Utility methods for <code>Sketch</code>.\nAssert that the sketch is consistent, return error …\nCheck that context formula is valid. If not, return error …\nCheck that dataset is valid. If not, return error with a …\nCheck if all fields of the dynamic property are filled and …\nCheck that function is valid in a model. If not, return …\nCheck that input index of uninterpreted function is in …\nCheck whether observation is valid in a dataset. If not, …\nCheck if all fields of the static property are filled and …\nCheck that variable is valid in a model. If not, return …\nPart of the consistency check responsible for the ‘…\nPart of the consistency check responsible for the ‘…\nPart of the consistency check responsible for the ‘model…\nPart of the consistency check responsible for the ‘…\nParse and validate all components of <code>Sketch</code> from a …\nDefault empty sketch.\nExport the sketch instance into a customized version of …\nExport the sketch instance into a custom JSON model format.\nExtract positions of nodes from the aeon model string. …\nExtract list of named entities (tuples with id/content) …\nReturns the argument unchanged.\nCreate sketch instance from a customized version of AEON …\nCreate sketch instance from a BooleanNetwork instance of …\nCreate sketch instance from a custom JSON model format.\nCreate sketch instance from a SBML model format. This …\nGet annotation string.\nCalls <code>U::from(self)</code>.\nModify this <code>Sketch</code> instance by loading all its components …\nModify this <code>Sketch</code> instance by loading all its components …\nCreate a new <code>Sketch</code> instance given a corresponding …\nGiven a <code>ModelAnnotation</code> node corresponding to a particular …\nGeneral check that all components of the sketch are …\nSet annotation string.\nModify this <code>Sketch</code> instance to a default (empty) settings.\nConvert the sketch instance into a customized version of …\nConvert the sketch instance into a custom (pretty) JSON …\n<strong>(internal)</strong> Simple internal utility to append issue message …\nConstants for event path segments for various events.\nUtility method to convert <code>Essentiality</code> from boolean.\nUtility method to convert <code>Essentiality</code> into boolean.\nUtility to convert monotonicity enum used by <code>lib_param_bn</code> …\nUtility to convert regulation sign from enum type used in …\nStructure for receiving data about changes in essentiality …\nStructure for receiving data about changes in monotonicity …\nStructure for sending data about changes in object’s ID …\nStructure for sending data about <code>Dataset</code> .\nStructure for sending <em>metadata</em> about <code>Dataset</code>. This …\nStructure for sending data about dynamic properties to the …\nEnum covering all variants of dynamic properties and their …\nStructure for sending simplified general data about <code>Layout</code> …\nStructure for sending <em>metadata</em> about <code>Layout</code>. This includes …\nStructure for sending data about <code>NodeLayout</code> to frontend.\nThe same as <code>LayoutNodeData</code>, but does not have a fixed …\nStructure for sending/exporting all necessary data about …\nStructure for sending data about <code>Observation</code> to the …\nStructure for sending simplified data about <code>Regulation</code> to …\nStructure for sending/exporting data about the whole …\nStructure for sending data about static properties to the …\nEnum covering all variants of static properties and their …\nStructure for sending data about <code>UninterpretedFn</code> to the …\nStructure for sending data about <code>Variable</code> and its <code>UpdateFn</code> …\nStructure for receiving data about <code>Variable</code> and all of its …\n<strong>(internal)</strong> Definition and utility methods for <code>DatasetData</code> …\n<strong>(internal)</strong> Definition and utility methods for all kinds of …\n<strong>(internal)</strong> Definition and utility methods for …\n<strong>(internal)</strong> Definition and utility methods for <code>ChangeIdData</code>.\n<strong>(internal)</strong> Definition and utility methods for <code>LayoutData</code> …\n<strong>(internal)</strong> Definition and utility methods for …\n<strong>(internal)</strong> Definition and utility methods for <code>ModelData</code>.\n<strong>(internal)</strong> Definition and utility methods for …\n<strong>(internal)</strong> Definition and utility methods for …\n<strong>(internal)</strong> Definition and utility methods for <code>SketchData</code>.\n<strong>(internal)</strong> Definition and utility methods for all kinds of …\n<strong>(internal)</strong> Definition and utility methods for …\n<strong>(internal)</strong> Definition and utility methods for <code>VariableData</code>.\nStructure for sending data about <code>Dataset</code> .\nStructure for sending <em>metadata</em> about <code>Dataset</code>. This …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new <code>DatasetData</code> object given a reference to a …\nCreate new <code>DatasetMetaData</code> object given a reference to a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the <code>DatasetData</code> to the corresponding <code>Dataset</code>. …\nSimplified variant to carry data regarding …\nStructure for sending data about dynamic properties to the …\nEnum covering all variants of dynamic properties and their …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new <code>DynPropertyData</code> object given a reference to a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nShorthand to create new generic <code>DynPropertyData</code> instance …\n<strong>(internal)</strong> Shorthand to create new <code>DynPropertyData</code> …\nExtract the corresponding <code>DynProperty</code> instance from this …\nStructure for receiving data about changes in essentiality …\nStructure for receiving data about changes in monotonicity …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>ChangeArgMonotoneData</code> object given the …\nCreate new <code>ChangeArgEssentialData</code> object given the …\nStructure for sending data about changes in object’s ID …\nReturns the argument unchanged.\nCreate new <code>ChangeIdData</code> object given uninterpreted fn IDs.\nCreate new <code>ChangeIdData</code> object given layout IDs.\nCreate new <code>ChangeIdData</code> object given variable IDs.\nCalls <code>U::from(self)</code>.\nCreate new <code>ChangeIdData</code> object given the two id slices. …\nCreate new <code>ChangeIdData</code> object given the two id slices and …\nStructure for sending simplified general data about <code>Layout</code> …\nStructure for sending <em>metadata</em> about <code>Layout</code>. This includes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new <code>LayoutData</code> instance given a <code>layout</code> and its id.\nCreate new <code>LayoutMetaData</code> instance given a <code>layout</code> and its …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>LayoutMetaData</code> instance given a layout’s name …\nExtract new <code>Layout</code> instance from this data.\nStructure for sending data about <code>NodeLayout</code> to frontend.\nThe same as <code>LayoutNodeData</code>, but does not have a fixed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new <code>LayoutNodeData</code> instance given a node’s layout …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>LayoutNodeData</code> instance given a node’s layout …\nExtract new <code>LayoutNode</code> instance from this data.\nStructure for sending/exporting all necessary data about …\nReturns the argument unchanged.\nCreate new <code>SketchData</code> instance given a reference to a …\nCalls <code>U::from(self)</code>.\nStructure for sending data about <code>Observation</code> to the …\nReturns the argument unchanged.\nCreate new <code>ObservationData</code> instance given a reference to a …\nCalls <code>U::from(self)</code>.\nCreate new <code>ObservationData</code> instance given all its …\nExtract the corresponding <code>Observation</code> from the …\nStructure for sending simplified data about <code>Regulation</code> to …\nReturns the argument unchanged.\nCreate new <code>RegulationData</code> object given a <code>regulation</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>RegulationData</code> object given references to …\nExtract new <code>Regulation</code> instance from this data.\nTry to create new <code>RegulationData</code> object given a string …\nStructure for sending/exporting data about the whole …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate new <code>SketchData</code> instance given a reference to all …\nCreate new <code>SketchData</code> instance given a reference to the …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nSimplified variant to carry data regarding …\nStructure for sending data about static properties to the …\nEnum covering all variants of static properties and their …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new <code>StatPropertyData</code> object given a reference to a …\n<strong>(internal)</strong> Convert function input from its string format …\n<strong>(internal)</strong> Convert function input from its index <code>N</code> into …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nShorthand to create new generic <code>StatPropertyData</code> instance …\n<strong>(internal)</strong> Shorthand to create new <code>StatPropertyData</code> …\nExtract the corresponding <code>StatProperty</code> instance from this …\nStructure for sending data about <code>UninterpretedFn</code> to the …\nReturns the argument unchanged.\nCreate new <code>UninterpretedFnData</code> object given an …\nCalls <code>U::from(self)</code>.\nCreate new <code>UninterpretedFnData</code> object given an …\nExtract new <code>UninterpretedFn</code> instance from this data (if …\nStructure for sending data about <code>Variable</code> and its <code>UpdateFn</code> …\nStructure for receiving data about <code>Variable</code> and all of its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new <code>VariableData</code> object given a reference to a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new <code>VariableData</code> object given a variable’s <code>name</code> …\nExtract new <code>Variable</code> instance from this data.\nShorthand to create a “refresh” event for a list of …\nShorthand to create a <code>Consumed::Reversible</code> instance given …\nShorthand to create a “state-change” event given a …\nPrepare event for the <code>dynamic properties</code> component of the …\nPrepare “state-change” event for the <code>dynamic properties</code>…\nPrepare event for the <code>model</code> component of the <code>sketch</code>, given …\nPrepare “state-change” event for the <code>model</code> component …\nPrepare event for the <code>observations</code> component of the <code>sketch</code>…\nPrepare “state-change” event for the <code>observations</code> …\nPrepare event for the <code>static properties</code> component of the …\nPrepare “state-change” event for the <code>static properties</code> …\n<strong>(internal)</strong> A base class to derive type-safe identifiers …\nA type-safe (string-based) identifier of a <code>Dataset</code> inside …\nA type-safe (string-based) identifier of a <code>DynProperty</code> …\nA regular expression that matches the identifiers allowed.\n<strong>(internal)</strong> A regex string of an identifier which we …\nA type-safe (string-based) identifier of a <code>Layout</code> inside a …\nA type-safe (string-based) identifier of a <code>Observation</code> …\nA type-safe (string-based) identifier of a <code>StatProperty</code> …\nA type-safe (string-based) identifier of a <code>UninterpretedFn</code> …\nA type-safe (string-based) identifier of a <code>Variable</code> inside …\nAccess the identifier as a string slice.\nAccess the identifier as a string slice.\nAccess the identifier as a string slice.\nAccess the identifier as a string slice.\nAccess the identifier as a string slice.\nAccess the identifier as a string slice.\nAccess the identifier as a string slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMacro to define various kinds of type-safe identifiers …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the string is a valid (C-like) identifier.\nTry to parse new identifier from a string.\nTry to parse new identifier from a string.\nTry to parse new identifier from a string.\nTry to parse new identifier from a string.\nTry to parse new identifier from a string.\nTry to parse new identifier from a string.\nTry to parse new identifier from a string.\nStructure to capture all the layout data regarding one …\nA node for a particular <code>Variable</code>’s in a particular <code>Layout</code>…\nAn iterator over all (<code>VarId</code>, <code>NodeLayout</code>) pairs of a <code>Layout</code>.\nPosition of a particular <code>LayoutNode</code> at the editor’s …\n<strong>(internal)</strong> Utility methods for <code>Layout</code>.\n<strong>(internal)</strong>  Utility methods for <code>NodeLayout</code>.\n<strong>(internal)</strong>  Utility methods for <code>NodePosition</code>.\nStructure to capture all the layout data regarding one …\nAdd a new default node (at 0,0) for a given variable.\nAdd a new (pre-generated) node.\nAdd a new node for a given variable to this layout. …\n<strong>(internal)</strong> Utility method to ensure there is no node for …\n<strong>(internal)</strong> Utility method to ensure there is a node for a …\nChange id of a variable with <code>original_id</code> to <code>new_id</code>.\nReturns the argument unchanged.\nHuman-readable name of this layout.\nLayout information regarding the node for a particular …\nNumber of nodes in this layout.\nNumber of nodes in this layout.\nCalls <code>U::from(self)</code>.\nReturn an iterator over all nodes of this layout.\nCreate new <code>Layout</code> with a given name and nodes.\nCreate new empty <code>Layout</code> (i.e., with no nodes) with a given …\nCreate new <code>Layout</code> with a given name, that is a direct copy …\nCreate new <code>Layout</code> with a given name, which will contain …\nRemove a node for a given variable from this layout.\nRename this <code>Layout</code>.\nUpdate position of a node for a given variable.\nA node for a particular <code>Variable</code>’s in a particular <code>Layout</code>…\nChange node’s coordinates.\nGenerate new <code>LayoutNode</code> at (0,0).\nReturns the argument unchanged.\nGet the pair of coordinates.\nGet the first (x) coordinate.\nGet the second (y) coordinate.\nCalls <code>U::from(self)</code>.\nCreate new <code>LayoutNode</code> of the regulatory graph.\nPosition of a particular <code>LayoutNode</code> at the editor’s …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBinary Boolean operation.\nEnum for all possible Boolean binary operators occurring …\nA true/false constant.\nPossible variants of essentiality of a <code>Regulation</code>.\nData regarding an argument of an uninterpreted function.\nSyntactic tree of a partially defined Boolean function. …\nAn iterator over all (<code>LayoutId</code>, <code>Layout</code>) pairs of a …\nObject representing the state of the model in the Boolean …\nPossible variants of (non)-monotonous effects of a …\nNegation.\nReferences a “placeholder network variable” that …\nDescribes an interaction between two variables, <code>regulator</code> …\nAn iterator over all <code>Regulations</code> of a <code>ModelState</code>.\nAn uninterpreted function of a partially specified model.\nReferences a network parameter (uninterpreted function). …\nAn iterator over all (<code>UninterpretedFnId</code>, <code>UninterpretedFn</code>) …\nUpdate function of a <code>BooleanNetwork</code>.\nAn iterator over all (<code>VarId</code>, <code>UpdateFn</code>) pairs of a …\nReferences a network variable.\nA type safe object for a Boolean variable of a <code>ModelState</code>.\nAn iterator over all (<code>VarId</code>, <code>Variable</code>) pairs of a …\n<strong>(internal)</strong> Definition and utility methods for <code>BinaryOp</code>.\n<strong>(internal)</strong> Definition and utility methods for <code>Essentiality</code>.\n<strong>(internal)</strong> Definition and utility methods for <code>FnTree</code>.\n<strong>(internal)</strong> Definition and utility methods for the manager …\n<strong>(internal)</strong> Definition and utility methods for <code>Monotonicity</code>.\n<strong>(internal)</strong> Definition and utility methods for <code>Regulation</code>.\n<strong>(internal)</strong> Definition and utility methods for …\n<strong>(internal)</strong> Definition and utility methods for <code>FnArgument</code>.\n<strong>(internal)</strong> Definition and utility methods for <code>UpdateFn</code>.\n<strong>(internal)</strong> Definition and utility methods for <code>Variable</code>.\nEnum for all possible Boolean binary operators occurring …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPossible variants of essentiality of a <code>Regulation</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBinary Boolean operation.\nA true/false constant.\nSyntactic tree of a partially defined Boolean function. …\nNegation.\nReferences a “placeholder network variable” that …\nReferences a network parameter (uninterpreted function). …\nReferences a network variable.\nReturn a set of all uninterpreted functions (parameters) …\nReturn a set of all variables that are actually used in …\nReturns the argument unchanged.\nObtain the <code>FnTree</code> from a similar <code>FnUpdate</code> object of the …\nRecursively obtain the <code>FnTree</code> from a similar <code>FnUpdate</code> …\nCalls <code>U::from(self)</code>.\nA wrapper function for parsing update function formulas …\nUse this function as a template to create a new one, but …\nUse this function as a template to create a new one, but …\nRecursively transform the <code>FnTree</code> to a similar <code>FnUpdate</code> …\nConvert this update function to a string.\nTry to parse an update function from a string, taking IDs …\nObject representing the state of the model in the Boolean …\n<strong>(internal)</strong> Methods for converting between <code>ModelState</code> and …\n<strong>(internal)</strong> Methods for converting between <code>ModelState</code> and …\n<strong>(internal)</strong> Methods for safely constructing or editing …\n<strong>(internal)</strong> Implementation of the safe identifier …\n<strong>(internal)</strong> Methods for observing instances of <code>ModelState</code> …\n<strong>(internal)</strong> Implementation of event-based API for the …\nInternal utility to extract the regulatory graph (…\n<strong>(internal)</strong> Utility method to add a default update fn for a …\nAdd a new uninterpreted fn with given <code>id</code>, <code>name</code> and <code>arity</code> …\nAdd a new uninterpreted fn with given string <code>id</code>, <code>name</code>, and …\nAdd a new <code>Layout</code> with given <code>layout_id</code> and <code>name</code> to this …\nAdd a new <code>Layout</code> with given <code>layout_id</code> and <code>name</code> to this …\nShorthand to add a list of new <code>Regulations</code> given by their …\nShorthand to add a list of new uninterpreted fns, each …\nShorthand to add a list of new variables with given string …\nAdd a new (pre-generated) <code>Layout</code> with given <code>id</code> to this …\n<strong>(internal)</strong> Utility method to add as many placeholder …\nAdd a new <code>Regulation</code> to this <code>ModelState</code>.\nAdd a new <code>Regulation</code> to this <code>ModelState</code> using a string …\nAdd a new uninterpreted fn given by its components.\nAdd a new variable with given <code>var_id</code> and <code>name</code> to this …\nAdd a new variable with given <code>id</code> and <code>name</code> to this …\n<strong>(internal)</strong> Utility method to ensure that an uninterpreted …\n<strong>(internal)</strong> Utility method to ensure there is no layout …\n<strong>(internal)</strong> Utility method to ensure there is no regulation …\n<strong>(internal)</strong> Utility method to ensure there is no …\n<strong>(internal)</strong> Utility method to ensure there is no variable …\n<strong>(internal)</strong> Utility method to ensure there is a layout with …\n<strong>(internal)</strong> Utility method to ensure there is a …\n<strong>(internal)</strong> Utility method to ensure there is a variable …\nShorthand to change essentiality of a <code>Regulation</code> pointing …\nShorthand to change sign of a <code>Regulation</code> pointing from …\nDecrement the arity of an uninterpreted fn given by id …\nDefault model object with no Variables, Uninterpreted …\nPerform event of adding a new “default” …\nPerform event of adding a new <code>variable</code> component to this …\nPerform event of adding a new <code>layout</code> component to this …\nPerform event of adding a new <code>regulation</code> component to this …\nPerform event of adding a new <code>regulation</code> component to this …\nPerform event of adding a new <code>uninterpreted fn</code> component …\nPerform event of adding a new <code>variable</code> component to this …\nPerform event of adding a new <code>variable</code> component to this …\nPerform event of modifying or removing existing <code>layout</code> …\nPerform event of modifying or removing existing <code>regulation</code> …\nPerform event of modifying or removing existing …\nPerform event of modifying or removing existing <code>variable</code> …\nReturns the argument unchanged.\nConvert the <code>ModelState</code> into the corresponding …\nConvert the <code>RegulatoryGraph</code> into the corresponding …\nGenerate valid <code>LayoutId</code> that’s currently not used by …\nGenerate valid <code>UninterpretedFnId</code> that’s currently not …\nGenerate valid <code>VarId</code> that’s currently not used by any …\nReturn a default <code>Layout</code>.\nStatic fn to get <code>LayoutId</code> of the default layout (same for …\nStatic fn to get name of the default layout (same for all …\nReturn a <code>Layout</code> corresponding to the given <code>LayoutId</code>.\nReturn a valid layout’s <code>LayoutId</code> corresponding to the Id …\nShorthand for getting a string name of a layout.\nShorthand for getting a position of a node for given …\nReturn a valid placeholder variable’s <code>VarId</code> …\nFind a <code>Regulation</code> between two variables if it exists.\nShorthand to find a <code>Regulation</code> between two variables …\nReturn a <code>UninterpretedFn</code> corresponding to a given …\nReturn annotation of a <code>UninterpretedFn</code> corresponding to a …\nReturn arity of a <code>UninterpretedFn</code> corresponding to a given …\nReturn a valid uninterpreted fn’s <code>UninterpretedFnId</code> …\nGet an update function for the given variable.\nGet an update function’s expression for the given …\nShortcut to return an annotation of the variable …\nReturn a valid variable’s <code>VarId</code> corresponding to the …\nShortcut to return a name of the variable corresponding to …\nReturn a <code>Variable</code> corresponding to a given <code>VarId</code>.\nGet a list of variables with “empty” update function. …\nIncrement the arity of an uninterpreted fn given by id …\n<strong>(internal)</strong> Shorthand method for adding a variable node to …\n<strong>(internal)</strong> Shorthand method for adding a variable node to …\n<strong>(internal)</strong> Utility method to add a variable node to a …\nCalls <code>U::from(self)</code>.\nCheck if there is a layout with given Id.\nCheck if the given <code>id</code> corresponds to some layout’s valid …\nCheck if there is a placeholder variable with given Id.\nCheck if there is a uninterpreted fn with given Id.\nCheck if the given <code>id</code> corresponds to some uninterpreted fn…\nCheck if there is a variable with given Id.\nCheck if the given <code>id</code> corresponds to some variable’s …\nCheck whether variable is used in any update function’s …\nReturn an iterator over all layouts (with IDs) of this …\nCreate a new <code>ModelState</code> that does not contain any <code>Variables</code>…\nCreate a new <code>ModelState</code> given a corresponding <code>ModelData</code> …\nCreate new <code>ModelState</code> using provided variable ID-name …\nThe number of layouts in this <code>ModelState</code>.\nThe number of placeholder variables in this <code>ModelState</code>.\nThe number of regulations in this <code>ModelState</code>.\nThe number of uninterpreted_fns in this <code>ModelState</code>.\nThe number of variables in this <code>ModelState</code>.\nPerform events related to <code>layouts</code> component of this …\nPerform events related to <code>regulations</code> component of this …\nPerform events related to <code>uninterpreted fns</code> component of …\nPerform events related to <code>variables</code> component of this …\nGet a list with all nodes in a specified layout.\nGet a list of all layouts (just basic information like IDs …\nGet a list of all regulations.\nGet a list of all uninterpreted fns.\nGet a list of all variables.\nGet a whole model.\nReturn an iterator over all regulations of this model.\nReturn a sorted list of variables that regulate the given …\n<strong>(internal)</strong> Remove all <code>Regulations</code> where <code>variable</code> figures …\n<strong>(internal)</strong> Utility method to remove a variable node from …\nRemove a <code>Layout</code> with given <code>layout_id</code> from this <code>ModelState</code>. …\nRemove a <code>Layout</code> with given <code>id</code> from this <code>ModelState</code>.\n<strong>(internal)</strong> Utility method to remove as many placeholder …\nRemove a <code>Regulation</code> pointing from <code>regulator</code> to <code>target</code> from …\nRemove a <code>Regulation</code> given by <code>regulation_str</code> from this …\nRemove the uninterpreted fn with given <code>fn_id</code> from this …\nRemove the uninterpreted_fn with given string <code>id</code> from this …\nRemove the network variable with given <code>var_id</code> from this …\nRemove the network variable with given <code>var_id</code> from this …\nSet annotation of an uninterpreted fn given by id <code>fn_id</code>.\nSet annotation of an uninterpreted fn given by string <code>id</code>.\nSet update functions for multiple variables (given …\nSet the raw uninterpreted function data for a function …\nSet the raw variable data for a variable <code>var_id</code>.\nSet constraints on all arguments of given uninterpreted fn.\nSet constraints on all arguments of given uninterpreted fn.\nSet arity of an uninterpreted fn given by id <code>fn_id</code>.\nSet the arity of an uninterpreted fn given by string <code>id</code>.\nSet essentiality of an argument of given uninterpreted fn …\nSet essentiality of an argument of given uninterpreted fn …\nSet expression of an uninterpreted fn given by id <code>fn_id</code>.\nSet expression of an uninterpreted fn given by string <code>id</code>.\nSet the id of an uninterpreted fn with <code>original_id</code> to …\nSet the id of an uninterpreted fn given by string …\nSet monotonicity of an argument of given uninterpreted fn …\nSet monotonicity of an argument of given uninterpreted fn …\nSet the name of an uninterpreted fn given by id <code>fn_id</code>.\nSet the name of an uninterpreted fn given by string <code>id</code>.\nSet update function for a given variable to a provided …\nSet the annotation of a network variable given by id <code>var_id</code>…\nSet the annotation of a network variable given by id <code>var_id</code>…\nSet the id of variable with <code>original_id</code> to <code>new_id</code>.\nSet the id of variable given by string <code>original_id</code> to …\nSet the name of a network variable given by id <code>var_id</code>. The …\nSet the name of a network variable given by string <code>id</code>.\nReturn a sorted list of variables that are regulated by …\nConvert the <code>ModelState</code> into the corresponding …\nInternal function to convert the <code>ModelState</code> into a variant …\nConvert the <code>ModelState</code> into the corresponding …\nConvert the <code>ModelState</code> into the corresponding “default”…\nConvert the <code>ModelState</code> into the corresponding “default”…\nGenerate a <code>BooleanNetwork</code> with a only given number of “…\nExtract the regulatory graph (<code>RegulatoryGraph</code> object) from …\nExtract the regulatory graph (<code>RegulatoryGraph</code> object) from …\nReturn an iterator over all uninterpreted_fns (with IDs) …\nReturn an iterator over all update functions (with …\nUpdate position of a node for variable <code>var_id</code> in layout …\nReturn an iterator over all variables (with IDs) of this …\nId (and also name) of the initial default layout.\n<strong>(internal)</strong> Implementation for events related to <code>layouts</code> of …\n<strong>(internal)</strong> Implementation for events related to <code>regulations</code>…\n<strong>(internal)</strong> Implementation for events related to …\n<strong>(internal)</strong> Implementation for events related to <code>variables</code> …\n<strong>(internal)</strong> Implementation for <code>refresh</code> (getter) events.\nPossible variants of (non)-monotonous effects of a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>(internal)</strong> A regex string of an identifier which we …\n<strong>(internal)</strong> Regex which matches the regulation arrow string …\n<strong>(internal)</strong> A regex which reads one line specifying a …\nDescribes an interaction between two variables, <code>regulator</code> …\nStandard format that can be parsed back.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the essentiality of the regulation.\nGet the <code>VarId</code> of the regulator.\nGet the sign of the regulation.\nGet the <code>VarId</code> of the target.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the regulation is marked as essential.\nCreate new <code>Regulation</code> given all the components.\nDirectly swap original essentiality with a given one.\nDirectly swap original regulator with a given one.\nDirectly swap original sign with a given one.\nDirectly swap original target with a given one.\nTry to read all available information about a regulation …\nTry to read the regulation from a given string in the …\nAn uninterpreted function of a partially specified model.\nAdd an argument with specified monotonicity/essentiality. …\nAdd default argument (with unknown …\nReturn a set of all uninterpreted fns that are actually …\nReturn a set of all variables that are actually used as …\nDrop the last argument of the function, essentially …\nReturns the argument unchanged.\nGet list of all ordered arguments (<code>FnArgument</code> objects) of …\nAnnotation of this uninterpreted fn.\nGet function’s argument (<code>FnArgument</code> object) on given …\nRead arity (number of arguments) of this uninterpreted fn.\nGet <code>Essentiality</code> of argument with given <code>index</code> (starting …\nGet function’s expression.\nGet highest index of a variable that is actually used in …\nGet <code>Monotonicity</code> of argument with given <code>index</code> (starting …\nHuman-readable name of this uninterpreted fn.\nCalls <code>U::from(self)</code>.\nCreate new <code>UninterpretedFn</code> instance given all its raw …\nCreate new <code>UninterpretedFn</code> object that has no constraints …\nSet the properties for all arguments (essentially …\nChange annotation of this uninterpreted fn.\nSet properties of an argument with given <code>index</code> (starting …\nChange arity of this uninterpreted fn.\nSet <code>Essentiality</code> of argument with given <code>index</code> (starting …\nSet the function’s expression to a given string.\nSet <code>Monotonicity</code> of argument with given <code>index</code> (starting …\nRename this uninterpreted fn.\nSubstitute all occurrences of a given function symbol in …\nCreate uninterpreted function using another one as a …\nCreate uninterpreted function from another one, …\nData regarding an argument of an uninterpreted function.\nDefault <code>FnArgument</code> with unknown monotonicity and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNew <code>FnArgument</code> with given monotonicity and essentiality..\nUpdate function of a <code>BooleanNetwork</code>.\nReturn a set of all uninterpreted fns that are actually …\nReturn a set of all variables that are actually used as …\nDefault “empty” update function.\nReturns the argument unchanged.\nGet function’s expression.\nCalls <code>U::from(self)</code>.\nCheck if the update function is empty (fully unspecified).\nMake an “empty” update function (same as Self::default…\nSet the update function’s expression to a given string.\nSubstitute all occurrences of a given function symbol in …\nSubstitute all occurrences of a given function symbol in …\nReturn a set of all variables that are actually used as …\nCreate new <code>UpdateFn</code> from a provided expression.\nCreate update function from another one, substituting all …\nCreate update function from another one, substituting all …\nA type safe object for a Boolean variable of a <code>ModelState</code>.\nReturns the argument unchanged.\nAnnotation of the variable.\nHuman-readable name of this variable.\nCalls <code>U::from(self)</code>.\nCreate new <code>Variable</code> instance. Annotation is left empty.\nCreate new <code>Variable</code> instance with an annotation.\nChange annotation of this variable.\nRename this variable.\nAn ordered list of observations for given variables. The …\nAn iterator over all &lt;<code>DatasetId</code>, <code>Dataset</code>&gt; pairs of a …\nA single named observation, i.e., an ordered vector of …\nClass to manage all observations and datasets.\nEnum of possible values of network variables in each …\n<strong>(internal)</strong> Definition and methods for <code>Dataset</code>.\n<strong>(internal)</strong> Definition and methods for <code>ObservationManager</code>.\n<strong>(internal)</strong> Definition and methods for <code>Observation</code>.\n<strong>(internal)</strong> Definition and methods for <code>VarValue</code>.\nIndex map from observation IDs to their index in vector, …\nList of binarized observations.\nVariables captured by the observations.\nAn ordered list of observations for given variables. The …\n<strong>(internal)</strong> Basic utility methods for <code>Dataset</code>.\n<strong>(internal)</strong> Implementation of partial event-based API to …\n<strong>(internal)</strong> Implementation of the safe identifier …\nAdd variable to a specific index, and fill its values in …\nAdd variable to a specific index, and fill its values in …\n<strong>(internal)</strong> Utility method to ensure there is no …\n<strong>(internal)</strong> Utility method to ensure there is no variable …\n<strong>(internal)</strong> Utility method to ensure there is a observation …\n<strong>(internal)</strong> Utility method to ensure there is a variable …\nDefault dataset instance with no Variables or …\nPerform event of removing the last observation from this …\nPerform event of adding a completely new “empty” …\nPerform event of adding a new <code>observation</code> to the end of …\nReturns the argument unchanged.\nGenerate valid <code>ObservationId</code> that’s currently not used …\nGenerate valid <code>VarId</code> that’s currently not used by any …\nAnnotation string of the dataset.\nIndex of given variable.\nName of the dataset.\nObservation with given ID.\nID of an observation on given index.\nID of an observation on given index.\nGet index of given observation, or None (if not present). …\nObservation on given index (indexing starts at 0).\nGet <code>VarId</code> for a corresponding string identifier, if it is …\nVariable on given index.\nIndex map from observation IDs to their index in vector, …\nAdd observation to a given index in the dataset.\nCalls <code>U::from(self)</code>.\nCheck if observation is present in this dataset.\nCheck if variable is tracked in this dataset.\nCreate new dataset from a list of observations and …\nCreate new dataset from a list of observations and …\nShorthand to create new <code>empty</code> dataset over given …\nNumber of observations in the dataset.\nNumber of variables tracked by the dataset.\nVector of all observations.\nList of binarized observations.\nRemove observation from the end of the dataset. If no …\nAdd observation at the end of the dataset.\nRemove observation with given ID from the dataset. The ID …\nRemove variable and all the values corresponding to it …\nRemove variable and all the values corresponding to it …\nSet the list of all variable IDs (essentially renaming …\nSet the list with all variable IDs (essentially renaming …\nSet dataset’s annotation string.\nSet dataset’s name.\nSet annotation of a given observation.\nSet the id of an observation with <code>original_id</code> to <code>new_id</code>.\nSet the id of observation given by string <code>original_id</code> to …\nSet name of a given observation.\nSwap the whole observation data for given ID.\nSet the id of variable with <code>original_id</code> to <code>new_id</code>.\nSet the id of variable given by string <code>original_id</code> to …\nSwap value vector for an observation with given ID. The …\nMake a string describing this <code>Dataset</code> in a human-readable …\n<strong>(internal)</strong> Try converting variables string slices into …\nVector of all variable names.\nVector of all variables.\nVariables captured by the observations.\nClass to manage all observations and datasets.\n<strong>(internal)</strong> Implementation of the safe identifier …\n<strong>(internal)</strong> Functionality for loading datasets from file.\n<strong>(internal)</strong> Basic utility methods for <code>ObservationManager</code>.\n<strong>(internal)</strong> Implementation of event-based API for the …\nAdd a new dataset with given <code>id</code> to this <code>ObservationManager</code>.\nAdd a new dataset with given string <code>id</code> to this …\nShorthand to add a list of new datasets with given string …\nAdd variable column and fill all its values (in each …\nAdd variable column and fill all its values (in each …\n<strong>(internal)</strong> Utility method to ensure there is no dataset …\n<strong>(internal)</strong> Utility method to ensure there is a dataset …\nReturn an iterator over all datasets of this model.\nDefault manager instance with no datasets.\nPerform event of adding a new <code>dataset</code> to this …\nPerform event of adding a new DEFAULT (empty) <code>dataset</code> to …\nPerform event of loading (and adding) new <code>dataset</code> to this …\nPerform event of modifying or removing existing <code>dataset</code> …\nReturns the argument unchanged.\nInstantiate <code>ObservationManager</code> with given list of …\nGenerate valid <code>DatasetId</code> that’s currently not used by …\nGenerate valid <code>ObservationId</code> that’s currently not used …\nGenerate valid <code>VarId</code> that’s currently not used by any …\nReturn a <code>Dataset</code> corresponding to a given <code>DatasetId</code>.\nReturn a <code>Dataset</code> corresponding to a given id given as …\nReturn a valid dataset’s <code>DatasetId</code> corresponding to the …\nShorthand to get <code>Observation</code> with a given id, from a …\nShorthand to get <code>Observation</code> with a given string id, from …\nShorthand to get <code>ObservationId</code> from a specified dataset.\nCalls <code>U::from(self)</code>.\nCheck if there is a dataset with given Id.\nLoad a dataset from given CSV file, and add it to this …\nLoad a dataset from given CSV file. The header line …\nInstantiate <code>ObservationManager</code> with empty list of datasets.\nThe number of datasets in this <code>ObservationManager</code>.\nRemove the dataset with given <code>id</code> from this manager. …\nRemove the dataset with given string <code>id</code> from this manager. …\nRemove variable and all the values corresponding to it …\nRemove variable and all the values corresponding to it …\nSet the list of all variable IDs (in a given dataset), …\nSet the list of all variable IDs (in a given dataset), …\nSet annotation of a dataset with given id.\nSet annotation of a dataset with given string id.\nSet the id of dataset with <code>original_id</code> to <code>new_id</code>.\nSet the id of dataset with <code>original_id</code> to <code>new_id</code>.\nSet name of a dataset with given id. The name must be …\nSet name of a dataset with given string id. The name must …\nSet the id of a variable with <code>original_id</code> (in a given …\nSet the id of a variable with <code>original_id</code> (in a given …\nSwap content of a dataset with given <code>id</code>. The ID must be …\nSwap content of a dataset with given <code>id</code>. The ID must be …\nA single named observation, i.e., an ordered vector of …\nInsert value on given <code>index</code>, incrementing the dimension of …\nReturns the argument unchanged.\nAnnotation string of the observation.\nGet reference to observation’s id.\nGet observation’s name.\nGet reference to observation’s vector of values.\nCalls <code>U::from(self)</code>.\nCreate <code>Observation</code> object from a vector of values, and …\nCreate <code>Observation</code> object from a vector with values, …\nCreate <code>Observation</code> encoding a vector of <code>n</code> ones. Name is …\nCreate <code>Observation</code> encoding a vector of <code>n</code> unspecified …\nCreate <code>Observation</code> encoding a vector of <code>n</code> zeros. Name is …\nNumber of ones (<code>true</code> values) in this observation.\nNumber of specified values in this observation.\nNumber of unspecified values in this observation.\nNumber of all values in this observation (its “length”…\nNumber of zeros (<code>false</code> values) in this observation.\nRemove value on given <code>index</code>, decrementing the dimension of …\nSet all the values in this observation. The new vector of …\nSet all the values in this observation via its string …\nSet annotation string.\nSet the id of this observation.\nSet the id of this observation, given the potential ID as …\nSet name.\nSet the value at given idx.\nSet the value (one of the “0”/“1”/“*”) at …\nMake a string describing this <code>Observation</code> in a …\nMake a string with bit-encoding of values of this …\nCreate <code>Observation</code> object from string encoding of its …\nCreate <code>Observation</code> object from string encoding of its …\nValue at given index.\nEnum of possible values of network variables in each …\nReturn a string slice encoding this value (one of the <code>1</code>, <code>0</code>…\nTransform the value to one of the <code>1</code>, <code>0</code>, or <code>*</code>.\nReturns the argument unchanged.\nTry to parse the value. Valid strings are one of the <code>1</code>, <code>0</code>, …\nCalls <code>U::from(self)</code>.\nReturn <code>true</code> value if is not specified.\nReturn <code>true</code> value if is specified.\nReturn Boolean if value is specified, else None.\nAn iterator over all &lt;<code>DynPropertyId</code>, <code>DynProperty</code>&gt; pairs of …\nClass to manage all properties of the sketch.\nAn iterator over all &lt;<code>StatPropertyId</code>, <code>StatProperty</code>&gt; pairs …\n<strong>(internal)</strong> Definition and methods for <code>PropertyManager</code>.\nStructs and utilities regarding dynamic properties.\nUtilities and shortcuts for simpler property generating, …\nStructs and utilities regarding static properties.\nClass to manage all properties of the sketch.\n<strong>(internal)</strong> Implementation of the safe identifier …\n<strong>(internal)</strong> Basic utility methods for <code>PropertyManager</code>.\n<strong>(internal)</strong> Implementation of event-based API for the …\nAdd pre-generated dynamic property.\nAdd pre-generated dynamic property with id given by str.\nAdd pre-generated static property.\nAdd pre-generated static property with id given by str.\n<strong>(internal)</strong> Utility method to ensure there is no dynamic …\n<strong>(internal)</strong> Utility method to ensure there is no static …\n<strong>(internal)</strong> Utility method to ensure there is a dynamic …\n<strong>(internal)</strong> Utility method to ensure there is a static …\nDefault manager instance with no datasets.\nReturn an iterator over all dynamic properties of this …\nPerform event of adding a new DEFAULT <code>dynamic property</code> of …\nPerform event of adding a new DEFAULT <code>static property</code> of …\nPerform event of adding a new <code>dynamic property</code> to this …\nPerform event of adding a new <code>static property</code> to this …\nPerform event of modifying or removing existing …\nPerform event of modifying or removing existing …\nReturns the argument unchanged.\nGenerate valid <code>DynPropertyId</code> that’s currently not used …\nGenerate valid <code>StatPropertyId</code> that’s currently not used …\nReturn a <code>DynProperty</code> corresponding to a given <code>DynPropertyId</code>…\nReturn a valid dynamic property’s <code>DynPropertyId</code> …\nReturn a <code>StatProperty</code> corresponding to a given …\nReturn a valid static property’s <code>StatPropertyId</code> …\nCalls <code>U::from(self)</code>.\nCheck if there is a dynamic property with given Id.\nCheck if there is a static property with given Id.\nGo through all static properties that are automatically …\nInstantiate <code>PropertyManager</code> with empty sets of properties.\nInstantiate <code>PropertyManager</code> with dynamic and static …\nThe number of dynamic properties in this <code>PropertyManager</code>.\nThe number of static properties in this <code>PropertyManager</code>.\nRemove dynamic property.\nRemove static property.\nUpdate dynamic property’s sub-fields, if the property is …\nUpdate dynamic property’s sub-field <code>dataset</code> where …\nUpdate generic dynamic property’s formula. If not …\nChange ID of a dynamic property.\nChange ID of a dynamic property, with IDs given as string …\nSet name for given dynamic property.\nUpdate dynamic property’s sub-field <code>observation</code> to None …\nUpdate dynamic property’s sub-field <code>observation</code> where …\nUpdate dynamic property’s sub-fields, if the property is …\nUpdate static property’s sub-field for context, where …\nUpdate static property’s sub-field for essentiality, …\nUpdate generic static property’s formula. If not …\nChange ID of a static property.\nChange ID of a static property, with IDs given as string …\nUpdate static property’s sub-field for index of input …\nUpdate static property’s sub-field for input variable …\nUpdate static property’s sub-field for monotonicity, …\nSet name for given static property.\nUpdate static property’s sub-field for target …\nUpdate static property’s sub-field for target variable, …\nReturn an iterator over all dynamic properties of this …\nSwap content of a dynamic property with given <code>id</code>. The ID …\nSwap content of a dynamic property with given <code>id</code>. The ID …\nSwap content of a static property with given <code>id</code>. The ID …\nSwap content of a static property with given <code>id</code>. The ID …\nConstants for event path segments for various events.\nVariant of <code>DynProperty</code> requiring that the number of …\nA typesafe representation wrapping various kinds of …\nEnum covering all variants of dynamic properties and their …\nVariant of <code>DynProperty</code> requiring existence of a fixed …\nVariant of <code>DynProperty</code> requiring existence of a trajectory …\nVariant of <code>DynProperty</code> requiring existence of a trap space …\nVariant of <code>DynProperty</code> requiring that a particular HCTL …\nVariant of <code>DynProperty</code> requiring one of the following …\nA typesafe representation of a HCTL formula used in …\nEnum covering all variants of dynamic properties (only …\n<strong>(internal)</strong> Definition and methods for <code>DynProperty</code>.\n<strong>(internal)</strong> Definition and methods for <code>HctlFormula</code>.\n<strong>(internal)</strong> Variants of dynamic properties.\nCheck if two DynPropertyType instances are of the same …\nA typesafe representation wrapping various kinds of …\nCheck that the property has all required fields filled …\nCreate default <code>DynProperty</code> instance of specified variant.\nCreate default <code>DynProperty</code> instance for the number of …\nCreate default <code>DynProperty</code> instance for the existence of a …\nCreate default “generic” <code>DynProperty</code> instance, …\nCreate default <code>DynProperty</code> instance for the existence of …\nCreate default <code>DynProperty</code> instance for the existence of a …\nCreate default <code>DynProperty</code> instance for the existence of a …\nReturns the argument unchanged.\nGet annotation string.\nGet property’s name.\nGet property’s variant with all the underlying data.\nCalls <code>U::from(self)</code>.\nCreate <code>DynProperty</code> instance describing existence of a …\nCreate <code>DynProperty</code> instance describing the existence of an …\nCreate <code>DynProperty</code> instance describing existence of a …\nCreate <code>DynProperty</code> instance describing existence of a trap …\n<strong>(internal)</strong> Shorthand to create a property given its …\nUpdate property’s sub-field <code>observation</code> to None where …\nSet property’s annotation string.\nUpdate property’s sub-fields, if the property is of …\nUpdate property’s sub-field <code>dataset</code> where applicable. If …\nUpdate generic property’s formula. If not applicable …\nUpdate property’s name.\nUpdate property’s sub-field <code>observation</code> where …\nUpdate property’s sub-fields, if the property is of …\nCreate <code>DynProperty</code> instance describing the number of …\nCreate “generic” <code>DynProperty</code> instance directly from a …\nA typesafe representation of a HCTL formula used in …\nReference to a string form of the HCTL formula.\nChange the formula represented by this instance.\nAssert that formula is correctly formed based on HCTL …\nAssert that formula is correctly formed based on HCTL …\n<em>(internal)</em> Deserialize field <code>tree</code> of <code>HctlFormula</code> from the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA wrapper function for full preprocessing step for HCTL …\nA wrapper function for parsing HCTL formulas with extended …\n<em>(internal)</em> Serialize field <code>tree</code> of <code>HctlFormula</code> as a string.\nReference to a syntax tree of the HCTL formula.\nParse <code>HctlFormula</code> object directly from a string, which …\nVariant of <code>DynProperty</code> requiring that the number of …\nEnum covering all variants of dynamic properties and their …\nVariant of <code>DynProperty</code> requiring existence of a fixed …\nVariant of <code>DynProperty</code> requiring existence of a trajectory …\nVariant of <code>DynProperty</code> requiring existence of a trap space …\nVariant of <code>DynProperty</code> requiring that a particular HCTL …\nVariant of <code>DynProperty</code> requiring one of the following …\nEnum covering all variants of dynamic properties (only …\nCheck if two DynPropertyType instances are of the same …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nShorthand to get a static property that describes …\nShorthand to get a generic static property with FOL …\nShorthand to get a generic dynamic property with HCTL …\nShorthand to get a static property that describes …\nA typesafe representation of a FOL formula used in static …\nVariant of <code>StatProperty</code> requiring that an input (on …\nVariant of <code>StatProperty</code> requiring that an input (on …\nVariant of <code>StatProperty</code> requiring that a particular …\nVariant of <code>StatProperty</code> requiring that a regulation <code>input</code> …\nVariant of <code>StatProperty</code> requiring that a regulation <code>input</code> …\nEnum covering all variants of static properties (only …\nA typesafe representation of various kinds of static …\nEnum covering all variants of static properties and their …\n<strong>(internal)</strong> Definition and methods for <code>FirstOrderFormula</code>.\n<strong>(internal)</strong> Variants of static properties.\n<strong>(internal)</strong> Definition and methods for <code>StatProperty</code>.\nCheck if two StatPropertyType instances are of the same …\nA typesafe representation of a FOL formula used in static …\nReference to a string form of the FOL formula.\nChange the formula represented by this instance.\nCheck if the formula is correctly formed based on …\nCheck if the formula is correctly formed based on …\n<em>(internal)</em> Deserialize field <code>tree</code> of <code>FirstOrderFormula</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<em>(internal)</em> Serialize field <code>tree</code> of <code>FirstOrderFormula</code> as a …\nReference to a syntax tree of the first-order formula.\nParse <code>FirstOrderFormula</code> instance directly from a string, …\nVariant of <code>StatProperty</code> requiring that an input (on …\nVariant of <code>StatProperty</code> requiring that an input (on …\nVariant of <code>StatProperty</code> requiring that a particular …\nVariant of <code>StatProperty</code> requiring that a regulation <code>input</code> …\nVariant of <code>StatProperty</code> requiring that a regulation <code>input</code> …\nEnum covering all variants of static properties (only …\nEnum covering all variants of static properties and their …\nCheck if two StatPropertyType instances are of the same …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA typesafe representation of various kinds of static …\nCheck that the property has all required fields filled out.\nCreate default <code>StatProperty</code> instance of specified variant.\nCreate default <code>StatProperty</code> instance for function input …\nCreate default <code>StatProperty</code> instance for function input …\nCreate default <code>StatProperty</code> instance for function input …\nCreate default <code>StatProperty</code> instance for function input …\nCreate default “generic” <code>StatProperty</code> instance, …\nCreate default <code>StatProperty</code> instance for regulation …\nCreate default <code>StatProperty</code> instance for regulation …\nCreate default <code>StatProperty</code> instance for regulation …\nCreate default <code>StatProperty</code> instance for regulation …\nReturns the argument unchanged.\nGet annotation string.\nGet ID of a static property that describes essentiality of …\nGet ID of a static property that describes monotonicity of …\nGet property’s name.\nGet property’s variant with all the underlying data.\nGet property’s sub-fields for regulator variable and …\nCalls <code>U::from(self)</code>.\nCreate <code>StatProperty</code> instance describing that an input of …\nCreate <code>StatProperty</code> instance describing that an input of …\nCreate <code>StatProperty</code> instance describing that an input of …\nCreate <code>StatProperty</code> instance describing that an input of …\nCreate <code>StatProperty</code> instance describing that an input of …\nCreate <code>StatProperty</code> instance describing that an input of …\nCreate <code>StatProperty</code> instance describing that an input of …\nCreate <code>StatProperty</code> instance describing that an input of …\n<strong>(internal)</strong> Shorthand to create a property given its …\nSet property’s annotation string.\nUpdate property’s sub-field for context, where …\nUpdate property’s sub-field for essentiality, where …\nUpdate generic property’s formula. If not applicable …\nUpdate property’s sub-field for index of input (of an …\nUpdate property’s sub-field for input variable (of an …\nUpdate property’s sub-field for monotonicity, where …\nSet property’s name.\nUpdate property’s sub-field for target uninterpreted fn, …\nUpdate property’s sub-field for target variable, where …\nIf the property is referencing the given variable (as …\nCreate “generic” <code>StatProperty</code> instance directly from a …\nConvert keys of the <code>HashMap</code> from <code>String</code> to a given type. …\nConvert keys of the <code>HashMap</code> to <code>String</code>, and then order the …\nCheck that the list of (typesafe or string) IDs contains …\nCheck if a name string is valid, return Error otherwise.")